#나의 풀이
import math
def solution(k, d):
    i = 0
    l = 0
    j = 0
    answer = 0
    while l < d :
        #for p in 
        answer += 1
        j += 1            
        i += 1
        l = math.sqrt((i**2) + ((k*j)**2))
    return answer

a = solution(2, 4)
b = solution(1, 5)
print(a)
print(b)

#나는 거리(l)을 구하는 과정까지는 맞았다고 생각하는데
#1차원 직선 밖에 표현이 되지 않는다.
#2차원, 즉 y좌표의 값도 체크해서 하고싶었는데 실력이 부족한 나는 
#이중 for문을 돌아야겠다 라고 생각해놓고, 반복 횟수를 알 수 없어서 while문으로 돌아갔고, 심지어 배열을 선언하고 있었다.
#사람들을 보니 x= , y= , 으로 따로 선언해서 for문을 돌아 각각의 좌표 값 sqrt(x**2 + y**2)로 하여금 계산을 했는데 시간초과가 났다고 했다.
#따라서 for문은 1번만 돌아야한다는 것을 파악했고, 이 문제는 원의 1/4만을 그려서 푸는 전형적인 문제라고 한다.
#x좌표의 값은 쉽게 구할 수 있으니, 피타코라스의 정리 z^2 = x^2 + y^2 으로 부터 출발해서 y^2 = z^2 - x^2으로 이어져, y의 좌표를 floot형으로 구할 수 있고 4.xxx인 경우 4라는 정수는 포함이 되므로 
#카운트하면 총 개수를 구할 수 있다.

#다른 사람의 풀이
def solution(k, d):
    answer = 0
    for i in range(0, d+1 ,k):
        res = int((d**2 - i**2)**0.5)    #y좌표
        answer += (res // k) + 1
    return answer


#이 풀이의 방식은 x를 고정시키고 y의 개수를 잰다.
#거의 대다수의 사람은 나처럼 y를 고정시키면서 x의 변화를 볼텐데
#역으로 생각한 것이다.. 나도 이런 사고 과정을 배워야겠다..
#루트를 표현하고 싶으면 **0.5라는 것도 알게되었다.
